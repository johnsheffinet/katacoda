# Core Concepts (13%)

# 001. List all namespaces in cluster
kubectl get ns
# Answer
kubectl get namespaces

# 002. List all pods in cluster
kubectl get po --all-namespaces
# Answer
kubectl get pods -A

# 003. List all pods in specific namespace
kubectl get po --namespace=kube-system
# Answer
kubectl get pods -n kube-system

# 004. List all services in specific namespace
kubectl get svc --namespace=kube-system
# Answer
kubectl get services -n kube-system

# 005. List all pods showing name and namespace with jsonpath
kubectl get po --all-namespaces --output=jsonpath="{.items[*]['metadata.name','metadata.namespace']}{'\n'}"
# Answer
kubectl get pods -A -o jsonpath="{.items[*]['metadata.name', 'metadata.namespace']}{'\n'}"

# 006. Create nginx pod in default namespace and verify nginx pod is running
kubectl delete po/nginx && \
kubectl run nginx --restart=Never --image=nginx && \
kubectl wait --for=condition=Ready po/nginx && \
kubectl get po/nginx
# Answer
kubectl run nginx --restart=Never --image=nginx
kubectl get pods

# 007. Create nginx pod with yaml file
kubectl delete po/nginx && \
kubectl run nginx --restart=Never --image=nginx --dry-run --output=yaml > nginx.yaml && \
kubectl create --filename=nginx.yaml && \
kubectl wait --for=condition=Ready --filename=nginx.yaml && \
kubectl get po/nginx
# Answer
kubectl run nginx --restart=Never --image=nginx --dry-run -o yaml > nginx.yaml
kubectl create -f nginx.yaml

# 008. Show yaml file for nginx pod
kubectl get po/nginx --output=yaml
# Answer
kubectl get pods nginx -o yaml

# 009. Show yaml file for nginx pod without cluster-specific information
kubectl get po/nginx --output=yaml --export
# Answer
kubectl get pods nginx -o yaml --export

# 010. Show details for nginx pod
kubectl describe po/nginx
# Answer
kubectl describe pods nginx

# 011. Delete nginx pod
kubectl delete po/nginx && \
kubectl get po/nginx
# Answer
kubectl delete pods nginx

# 012. Delete nginx pod without waiting
kubectl run nginx --restart=Never --image=nginx && \
kubectl wait --for=condition=Ready po/nginx && \
kubectl delete po/nginx --grace-period=0 --force && \
kubectl wait --for=delete po/nginx && \
kubectl get po/nginx
# Answer
kubectl delete pods nginx --grace-period=0 --force

# 013. Create nginx pod with nginx:1.17.4 image and expose nginx pod on port 80
kubectl run nginx --restart=Never --image=nginx:1.17.4 --port=80 -- /bin/sh -c "sleep 3600" && \
kubectl wait --for=condition=Ready po/nginx && \
kubectl describe po/nginx
# Answer
kubectl run nginx --restart=Never --image=nginx:1.17.4 --port=80

# 014. Update nginx pod with alpine:3.11.3 image and verify image is updated
kubectl set image po/nginx nginx=alpine:3.11.3 && \
kubectl wait --for=condition=Ready po/nginx && \
kubectl describe po/nginx
# Answer
kubectl set image pod/nginx nginx=nginx:1.15-alpine
kubectl describe pods nginx

# 015. Update nginx pod with nginx:1.17.1 image and observe changes
kubectl set image po/nginx nginx=nginx:1.17.1 && \
kubectl get po/nginx --watch
# Answer
kubectl set image pod/nginx nginx=nginx:1.17.1
kubectl describe po nginx
kubectl get pods nginx -w

# 016. Verify image in nginx pod without describe command
kubectl get po/nginx --output=jsonpath="{.spec.containers[].image}{'\n'}"
# Answer
kubectl get po nginx -o jsonpath="{.spec.containers[].image}{'\n'}"

# 017. Create nginx pod and execute shell command
kubectl delete po/nginx && \
kubectl run nginx --restart=Never --image=nginx --port=80 && \
kubectl wait --for=condition=Ready po/nginx && \
kubectl exec nginx -it -- /bin/sh -c "ls"
# Answer
kubectl run nginx --restart=Never --image=nginx
kubectl exec -it nginx /bin/sh

# 018. Show IP address of nginx pod
kubectl get po/nginx --output=jsonpath="{.status.podIP}{'\n'}"
# Answer
kubectl get po nginx -o wide

# 019. Create busybox pod and execute ls command and show logs
kubectl run busybox --restart=Never --image=busybox -- /bin/sh -c "sleep 3600" && \
kubectl wait --for=condition=Ready po/busybox && \
kubectl exec busybox -- /bin/sh -c "ls" && \
kubectl logs busybox
# Answer
kubectl run busybox --restart=Never --image=busybox -- ls
kubectl logs busybox

# 020. Show previous logs of busybox pod
kubectl logs busybox --previous
# Answer
kubectl logs busybox -p

# 021. Create busybox pod and execute sleep 3600 command
kubectl delete po/busybox && \
kubectl run busybox --restart=Never --image=busybox -- /bin/sh -c "sleep 3600" && \
kubectl wait --for=condition=Ready po/busybox && \
kubectl get po/busybox
# Answer
kubectl run busybox --restart=Never --image=busybox -- /bin/sh -c "sleep 3600"

# 022. Verify connection from busybox pod to nginx pod
export POD_IP=$(kubectl get po/nginx --output=jsonpath="{.status.podIP}") && \
export POD_PORT=$(kubectl get po/nginx --output=jsonpath="{.spec.containers[].ports[0].containerPort}") && \
echo $POD_IP:$POD_PORT  && \
kubectl exec busybox -it -- /bin/sh -c "wget -O- $POD_IP:$POD_PORT"
# Answer
kubectl get po nginx -o wide
kubectl exec -it busybox -- wget -o- <IP Address>

# 023. Create busybox pod and execute echo 'How are you' command and delete pod manually
kubectl delete po/busybox && \
kubectl run busybox --restart=Never --image=busybox -- /bin/sh -c "sleep 3600" && \
kubectl wait --for=condition=Ready po/busybox && \
kubectl exec busybox -it -- /bin/sh -c "echo 'How are you'" && \
kubectl delete po/busybox
# Answer
kubectl run busybox --restart=Never --image=busybox -it -- echo 'How are you'
kubectl delete po busybox

# 024. Create busybox pod and execute echo 'How are you' command and delete pod immediately
kubectl run busybox --restart=Never --image=busybox --rm -it -- /bin/sh -c "echo 'How are you'" && \
kubectl get po/busybox
# Answer
kubectl run busybox --restart=Never --image=busybox -it --rm -- echo "How are you"

# 025. Create nginx pod and show different verbosity levels
kubectl delete po/nginx && \
kubectl run nginx --restart=Never --image=nginx && \
kubectl wait --for=condition=Ready po/nginx && \
kubectl get po/nginx --v=0 && \
kubectl get po/nginx --v=9
# Answer
kubectl run nginx --restart=Never --image=nginx --port=80
kubectl get po nginx --v=7
kubectl get po nginx --v=8
kubectl get po nginx --v=9

# 026. Show nginx pod with custom columns POD_NAME and POD_STATUS
kubectl get po/nginx --output=custom-columns='POD_NAME:.metadata.name, POD_STATUS:.status.containerStatuses[].state'
# Answer
kubectl get po --output=custom-columns="POD_NAME:.metadata.name, POD_STATUS:.status.containerStatuses[].state"

# 027. List all pods sorted by name
kubectl get po --all-namespaces --sort-by=.metadata.name
# Answer
kubectl get po --sort-by=.metadata.name

# 028. List all pods sorted by created time
kubectl get po --all-namespaces --sort-by=.metadata.creationTimestamp
# Answer
kubectl get po --sort-by=.metadata.creationTimestamp

# Multi-Container Pods (10%)

# 029. Create busybox pod with three busybox containers each executing "ls; sleep 3600", "echo 'Hello World'; sleep 3600" and "echo 'this is the third container'; sleep 3600" respectively and verify busybox pod is running
kubectl run busybox --restart=Never --image=busybox --dry-run --output=yaml -- /bin/sh -c "ls; sleep 3600"
cat << EOF >> busybox.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: busybox
  name: busybox
spec:
  containers:
  - args:
    - /bin/sh
    - -c
    - ls; sleep 3600
    image: busybox
    name: busybox1
    resources: {}
  - args:
    - /bin/sh
    - -c
    - echo 'Hello World'; sleep 3600
    image: busybox
    name: busybox2
    resources: {}
  - args:
    - /bin/sh
    - -c
    - echo 'this is the third container'; sleep 3600
    image: busybox
    name: busybox3
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Never
status: {}
EOF
kubectl delete po/busybox && \
kubectl create --filename=busybox.yaml && \
kubectl wait --for=condition=Ready po/busybox && \
kubectl get po/busybox && \
kubectl describe po/busybox
# Answer
kubectl run busybox --restart=Never --image=busybox --dry-run -o yaml -- bin/sh -c "ls; sleep 3600" > busybox.yaml
kubectl create -f busybox.yaml
kubectl get po busybox

# 030. Show logs for each container in busybox pod
kubectl logs busybox --container=busybox1 && \
kubectl logs busybox --container=busybox2 && \
kubectl logs busybox --container=busybox3
# Answer
kubectl logs busybox -c busybox1
kubectl logs busybox -c busybox2
kubectl logs busybox -c busybox3

# 031. Show previous logs for busybox2 container in busybox pod
kubectl logs busybox --container=busybox2 --previous
# Answer
kubectl logs busybox -c busybox2 --previous

# 032. Execute ls command in busybox3 container in busybox pod
kubectl exec busybox --container=busybox3 -it -- bin/sh -c "ls"
# Answer
kubectl exec busybox -c busybox3 -- ls

# 033. Show metrics for all containers in busybox pod with top.log
minikube addons enable metrics-server && \
kubectl top po > top.log && \
cat top.log
# Answer
kubectl top pod busybox --containers > file.log
cat file.log

# 034. Create busybox pod and execute "while true; do echo 'Hi I am from Main container' >> /var/log/index.html; sleep 5; done" command and add nginx container exposed on port 80 and verify all containers in busybox pod are running
kubectl run busybox --restart=Never --image=busybox --port=80 --dry-run --output=yaml -- /bin/sh -c "while true; do echo 'Hi I am from Main container' >> /var/log/index.html; sleep 5; done"
cat << EOF >> busybox.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: busybox
  name: busybox
spec:
  containers:
  - args:
    - /bin/sh
    - -c
    - while true; do echo 'Hi I am from Main container' >> /var/log/index.html; sleep 5; done
    image: busybox
    name: busybox
    resources: {}
    volumeMounts:
    - mountPath: /var/log
      name: log-vol
  - image: nginx
    name: nginx
    ports:
    - containerPort: 80
    resources: {}
    volumeMounts:
    - mountPath: /usr/share/nginx/html
      name: log-vol
  volumes:
  - name: log-vol
    emptyDir: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Never
status: {}
EOF
kubectl delete po/busybox && \
kubectl create --filename=busybox.yaml && \
kubectl wait --for=condition=Ready po/busybox && \
kubectl get po/busybox && \
kubectl describe po/busybox
# Answer
kubectl run busybox --restart=Never --image=busbox --dry-run -o yaml > busybox.yaml
kubectl create -f busybox.yaml
kubectl get po busybox

# 035. Verify main.txt exists in busybox container and show index.html in nginx container
kubectl exec busybox --container=busybox -it -- /bin/sh -c "ls /var/log/index.html" && \
export POD_IP=$(kubectl get po/busybox --output=jsonpath="{.status.podIP}{'\n'}") && \
export POD_PORT=$(kubectl get po/busybox --output=jsonpath="{.spec.containers[?(@.name=='nginx')].ports[0].containerPort}{'\n'}") && \
echo $POD_IP:$POD_PORT && \
kubectl exec busybox --container=busybox -it -- /bin/sh -c "wget -O- $POD_IP:$POD_PORT"
# Answer
kubectl exec busybox -c busybox -it -- sh cat /var/log/main.txt
kubectl exec busybox -c nginx -it -- sh cat /usr/share/nginx/html/index.html
kubectl exec busybox -c nginx -it -- sh apt-get update && apt-get install -y curl && curl localhost

# Pod Design (20%)

# 036. Show labels for all pods
kubectl get po --show-labels
# Answer
kubectl get pods --show-labels

# 037. Create 5, nginx pods where 2 have env=prd labels and 3 have env=dev labels
kubectl run nginx-dev1 --restart=Never --image=nginx --labels="env=dev" && \
kubectl run nginx-dev2 --restart=Never --image=nginx --labels="env=dev" && \
kubectl run nginx-dev3 --restart=Never --image=nginx --labels="env=dev" && \
kubectl run nginx-prd1 --restart=Never --image=nginx --labels="env=prd" && \
kubectl run nginx-prd2 --restart=Never --image=nginx --labels="env=prd"
# Answer
kubectl run nginx-dev1 --image=nginx --restart=Never --labels=env=dev
kubectl run nginx-dev2 --image=nginx --restart=Never --labels=env=dev
kubectl run nginx-dev3 --image=nginx --restart=Never --labels=env=dev
kubectl run nginx-prd1 --image=nginx --restart=Never --labels=env=prd
kubectl run nginx-prd2 --image=nginx --restart=Never --labels=env=prd

# 038. Verify all nginx pods are running with correct labels
kubectl get po --selector="env" --field-selector=status.phase==Running --show-labels
# Answer
kubeclt get pods --show-labels

# 039. List pods with env=dev label
kubectl get po --selector="env==dev"
# Answer
kubectl get pods -l env=dev

# 040. Show labels for pods with env=dev label
kubectl get po --selector="env in (dev)" --show-labels
# Answer
kubectl get pods -l env=dev --show-labels

# 041. List pods with env=prd label
kubectl get po --selector="env==prd"
# Amswer
kubectl get pods -l env=prod

# 042. Show labels for pods with env=prod label
kubectl get po --selector="env in (prd)" --show-labels
# Answer
kubectl get pods -l env=prod --show-labels

# 043. List pods with env label
kubectl get po --selector="env" --show-labels
# Answer
kubectl get pods -l env

# 044. List pods with env=dev or env=prod labels
kubectl get po --selector="env in (dev,prd)"
# Answer
kubectl get pods -l 'env in (dev,prod)'

# 045. Show labels for pods with env=dev or env=prod labels
kubectl get po --selector="env in (dev,prd)" --show-labels
# Answer
kubectl get pods -l 'env in (dev,prod)' --show-labels

# 046. Update nginx-dev3 pod with env=uat label and verify label is updated
kubectl label po/nginx-dev3 env=uat --overwrite && \
kubectl get po/nginx-dev3 --show-labels
# Answer
kubectl label pod/nginx-dev3 env=uat --overwrite
kubectl get pods --show-labels

# 047. Remowe all env labels from all nginx pods and verify all env labels are removed from all nginx pods
kubectl label po/nginx-dev{1..3} po/nginx-prd{1..2} env- && \
kubectl get po/nginx-dev{1..3} po/nginx-prd{1..2} --show-labels
# Answer
kubectl label pod nginx-dev{1..3} env-
kubectl label pod nginx-prod{1..2} env-
kubectl get po --show-labels

# 048. Add app=nginx label to all nginx pods and verify app=nginx label is added to all nginx pods
kubectl label po/nginx-dev{1..3} po/nginx-prd{1..2} app=nginx && \
kubectl get po --selector="app==nginx" --show-labels
# Answer
kubectl label pod nginx-dev{1..3} app=nginx
kubectl label pod nginx-prod{1..2} app=nginx
kubectl get po --show-labels

# 049. Show labels for all nodes
kubectl get no --show-labels
# Answer
kubectl get nodes --show-labels

# 050. Add nodeName=nginxnode label to minikube node and verify nodeName=nginxnode label is added to minikube node
kubectl label no/minikube nodeName=nginxnode && \
kubectl get no/minikube --show-labels
# Answer
kubectl label node minikube nodeName=nginxnode

# 051. Create nginx pod on node with nodeName=nginxnode label
kubectl run nginx --restart=Never --image=nginx --dry-run --output=yaml
cat << EOF >> nginx.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: nginx
  name: nginx
spec:
  containers:
  - image: nginx
    name: nginx
    resources: {}
  nodeSelector:
    nodeName: nginxnode
  dnsPolicy: ClusterFirst
  restartPolicy: Never
status: {}
EOF
kubectl delete po/nginx && \
kubectl create --filename=nginx.yaml && \
kubectl wait --for=condition=Ready po/nginx && \
kubectl get po/nginx --output=wide
# Answer
kubectl run nginx --image=nginx --restart=Never --dry-run -o yaml > pod.yaml
kubectl create -f pod.yaml

# 052. Verify nginx pod is running on minikube node
kubectl get po/nginx --output=wide
# Answer
kubectl describe po nginx | grep Node-Selectors

# 053. Verify nginx pod has Node-Selectors label
kubectl describe po/nginx | grep "Node-Selectors"
# Answer
kubectl describe po nginx | grep Labels

# 054. Annotate all nginx pods with name=webapp annotation
kubectl annotate po/nginx-dev{1..3} po/nginx-prd{1..2} name=webapp
# Answer
kubectl annotate pod nginx-dev{1..3} name=webapp
kubectl annotate pod nginx-prd{1..2} name=webapp

# 055. Verify all nginx pods have name=webapp annotation
kubectl get po/nginx-dev{1..3} po/nginx-prd{1..2} --output=jsonpath="{.items[*].metadata.annotations}{'\n'}"
# Answer
kubectl describe po nginx-dev{1..3} | grep -i annotations
kubectl describe po nginx-prod{1..2} | grep -i annotations

# 056. Remove all annotations on nginx pods and verify all annotations on nginx pods are removed
kubectl annotate nginx-dev{1..3},po/nginx-prd{1..2} name- && \
kubectl get po/nginx-dev{1..3} po/nginx-prd{1..2} --output=jsonpath="{.items[*].metadata.annotations}{'\n'}"
# Answer
kubectl annotate pod nginx-dev{1..3} name-
kubectl annotate pod nginx-prod{1..2} name-
kubectl describe po nginx-dev{1..3} | grep -i annotations
kubectl describe po nginx-prod{1..2} | grep -i annotations

# 057. Remove all nginx pods
kubectl delete po --all
# Answer
kubectl delete po --all

# 058. Create nginx deployment with 5 replicas
kubectl create deploy nginx --image=nginx --replicas=5 && \
kubectl rollout status deploy/nginx && \
kubectl get deploy/nginx
# Answer
kubectl create deploy nginx --image=nginx --replicas=5 --dry-run -o yaml > nginx.yaml
kubectl create -f nginx.yaml

# 059. Show labels for nginx deployment
kubectl get deploy/nginx --show-labels
# Answer
kubectl get deploy nginx --show-labels

# 060. Show yaml file for nginx deployment
kubectl get deploy/nginx --output=yaml
# Answer
kubectl get deploy nginx -o yaml

# 061. List pods for nginx deployment
kubectl get po --selector="app==nginx" --show-labels
# Answer
kubectl get deploy --show-labels
kubectl get pods -l app=nginx

# 062. Scale nginx deployment from 5 replicas to 20 replicas and verify nginx deployment has 20 replicas
kubectl scale deploy/nginx --replicas=20 && \
kubectl rollout status deploy/nginx && \
kubectl get deploy/nginx
# Answer
kubectl scale deploy nginx --replicas=20
kubectl get po -l app=nginx

# 063. Show nginx deployment rollout status
kubectl rollout status deploy/nginx
# Answer
kubectl rollout status deploy nginx

# 064. Show replicaset for nginx deployment
kubectl get rs --selector="app==nginx"
# Answer
kubectl get rs -l app=nginx

# 065. Show yaml file for replicaset and list pods for nginx deployment
kubectl get rs --selector="app==nginx" --output=yaml && \
kubectl get po --selector="app==nginx" --output=yaml
# Answer
kubectl get rs -l app=nginx -o yaml
kubectl get po -l app=nginx -o yaml

# 066. Delete nginx deployment and observe all pods being deleted
kubectl delete deploy/nginx && \
kubectl get po --selector="app=nginx" --watch
kubectl rollout status deploy/nginx
# Answer
kubectl delete deploy nginx
kubectl get po -l app=nginx -w

# 067. Create nginx deployment with nginx:1.17.1 image and expose nginx deployment on port 80 and verify image is correct
kubectl create deploy nginx --image=nginx:1.17.1 --port=80 && \
kubectl rollout status deploy/nginx && \
kubectl get deploy/nginx --output=jsonpath="{}{'\n'}"
# Answer
kubectl create deploy nginx --image=nginx:1.17.1 --dry-run -o yaml > nginx.yaml
kubectl create -f nginx.yaml
kubectl describe deploy nginx | grep Image

# 068. Update nginx deployment with nginx:1.17.4 image and verify image is updated
kubectl set image deploy/nginx nginx=nginx:1.17.4 && \
kubectl rollout status deploy/nginx && \
kubectl get deploy/nginx --output=jsonpath="{}{'\n'}"
# Answer
kubectl set image deploy/nginx nginx=nginx:1.17.4
kubectl describe deploy nginx | grep Image

# 069. Show revision history for nginx deployment
kubectl rollout history deploy/nginx
# Answer
kubectl rollout history deploy nginx
kubectl get deploy nginx --show-labels
kubectl get rs -l app=nginx
kubectl get po -l app=nginx

# 070. Undo nginx deployment with nginx:1.17.4 image and verify image is updated
kubectl rollout undo deploy/nginx && \
kubectl get deploy/nginx --output=jsonpath="{}{'\n'}"
# Answer
kubectl rollout undo deploy nginx
kubectl describe deploy nginx | grep Image

# 071. Update nginx deployment with nginx:1.16.1 image and verify image is updated and show revision history
kubectl set image deploy/nginx --nginx=nginx:1.16.1 && \
kubectl rollout status deploy/nginx && \
kubectl get deploy/nginx --output-jsonpath="{}{'\n'}" && \
kubectl rollout history deploy/nginx
# Answer
kubectl set image deploy/nginx nginx=nginx:1.16.1
kubectl describe deploy nginx | grep Image
kubectl rollout history deploy nginx

# 072. Update nginx deployment with nginx:1.17.1 image and verify image is updated
kubectl set image deploy/nginx nginx=nginx:1.17.1 && \
kubectl rollout status deploy/nginx &&
kubectl get deploy/nginx --output-jsonpath="{}{'\n'}"
# Answer
kubectl rollout undo deploy nginx --to-revision=3
kubectl describe deploy nginx | grep Image
kubectl rollout status deploy nginx

# 073. Update nginx deployment with nginx:1.100 image and verify image is not updated
kubectl set image deploy/nginx nginx=nginx:1.100 && \
kubectl rollout status deploy/nginx && \
kubectl get deploy/nginx && \
kubectl describe deploy/nginx
# Answer
kubectl set image deploy/nginx nginx=nginx:1.100
kubectl rollout status deploy nginx
kubectl get pods

# 074. Undo nginx deployment and verify ngix deployment is running
kubectl rollout undo deploy/nginx && \
kubectl rollout status deploy/nginx && \
kubectl get deploy/nginx
# Answer
kubectl rollout undo deploy nginx
kubectl rollout status deploy nginx
kubectl get pods

# 075. Show specific revision for nginx deployment
kubectl rollout history deploy/nginx --revision=7
# Answer
kubectl rollout history deploy nginx --revision=7

# 076. Pause nginx deployment
kubectl rollout undo deploy/nginx --to-revision=2 && \
kubectl rollout pause deploy/nginx && \
kubectl rollout status deploy/nginx
# Answer
kubectl rollout pause deploy nginx

# 077. Update nginx deployment with nginx:latest image and show revision history and verify update is not occuring
kubectl set image deploy/nginx nginx=nginx:latest && \
kubectl rollout status deploy/nginx && \
kubectl rollout history deploy/nginx
# Answer
kubectl set image deploy/nginx nginx=nginx:latest
kubectl rollout history deploy nginx

# 078. Resume nginx deployment
kubectl rollout resume deploy/nginx && \
kubectl rollout status deploy/nginx && \
kubectl rollout history deploy/nginx
# Answer
kubectl rollout resume deploy nginx

# 079. Show revision history and verify image is updated
kubectl rollout history deploy/nginx
# Answer
kubectl rollout history deploy nginx
kubectl rollout history deploy nginx --revision=9

# 080. Autoscale php-apache deployment between 10 and 20 replicas with target CPU of 85% and verify hpa is created and verify replicas are increased from 1 to 10
cat << EOF >> php-apache.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: php-apache
spec:
  selector:
    matchLabels:
      run: php-apache
  replicas: 1
  template:
    metadata:
      labels:
        run: php-apache
    spec:
      containers:
      - name: php-apache
        image: k8s.gcr.io/hpa-example
        ports:
        - containerPort: 80
        resources:
          limits:
            cpu: 500m
          requests:
            cpu: 200m

---

apiVersion: v1
kind: Service
metadata:
  name: php-apache
  labels:
    run: php-apache
spec:
  ports:
  - port: 80
  selector:
    run: php-apache
EOF
kubectl create --filename=php-apache.yaml && \
kubectl rollout status deploy/php-apache && \
kubectl autoscale deploy/php-apache --cpu-percent=85 --min=10 --max=20 && \
kubectl get deploy/php-apache --watch

export SVC_IP=$(kubectl get svc/php-apache --output=jsonpath="{}") && \
export SVC_PORT=$(kubectl get svc/php-apache --output=jsonpath="{}") && \
echo $SVC_IP:$SVC_PORT && \
kubectl run load-generator --generator=run-pod/v1 --image=busybox -- /bin/sh -c "while true; do wget -q -O- http://$SVC_IP:$SVC_PORT; done" && \
kubectl get hpa/php-apache --watch
kubectl delete po/load-generator
# Answer
kubectl autoscale deploy php-apache --cpu-percent=85 --min=10 --max=20 
kubectl get hpa
kubectl get pod -l app=php-apache

# 081. Delete php-apache deployment and delete php-apache hpa
kubectl delete deploy/php-apache hpa/php-apache && \
kubectl get deploy/php-apache hpa/php-apache
# Answer
kubectl delete deploy php-apache
kubectl delete hpa php-apache

# 082. Create node job and execute node -v command and verify pod is created
kubectl create job node --image=node -- /bin/sh -c "node -v" && \
kubectl get job/node
# Answer
kubectl create job nodeversion --image=node -- node -v
kubectl get job -w
kubectl get pod

# 083. Show logs for node job
kubectl logs node
# Answer
kubectl logs <pod name>

# 084. Show yaml file for busybox job and execute echo 'Hello I am from job' command 
kubectl create job busybox --image=busybox --dry-run --output=yaml -- /bin/sh -c "echo 'Hello I am from job'" > busybox.yaml
# Answer
kubectl create job hello-job --image=busybox --dry-run -o yaml -- echo "Hello I am from job"

# 085. Create busybox job from busybox.yaml file
kubectl create --filename=busybox.yaml && \
kubectl get job/busybox
# Answer
kubectl create job hello-job --image=busybox --dry-run -o yaml -- echo "Hello I am from job" > hello-job.yaml
kubectl create -f hello-job.yaml

# 086. Verify busybox job and pod are created and show busybox logs

# Answer
kubectl get job
kubectl get pokubectl logs hello-job-*

# 087. Delete busybox job

# Answer
kubectl delete job hello-job

# 088. Create busybox job and run busybox job run 10 times

# Answer
kubectl create job hello-job --image=busybox --dry-run -o yaml -- echo "Hello I am from job" > hello-job.yaml// edit the yaml file to add completions: 10
kubectl create -f hello-job.yaml

# 089. Watch busybox job and verify 10 pods are created and delete busybox pods

# Answer
kubectl get job -w
kubectl get pokubectl delete job hello-job

# 090. Create the same job and make it run 10 times parallel

# Answer
kubectl create job hello-job --image=busybox --dry-run -o yaml -- echo "Hello I am from job" > hello-job.yaml// edit the yaml file to add parallelism: 10
kubectl create -f hello-job.yaml

# 091. Watch the job that runs 10 times parallelly and verify 10 pods are created and delete those after it’s completed

# Answer
kubectl get job -w
kubectl get pokubectl delete job hello-job

# 092. Create a Cronjob with busybox image that prints date and hello from kubernetes cluster message for every minute

# Answer
kubectl create cronjob date-job --image=busybox --schedule="*/1 * * * *" -- bin/sh -c "date; echo Hello from kubernetes cluster"

# 093. Output the YAML file of the above cronjob

# Answer
kubectl get cj date-job -o yaml

# 094. Verify that CronJob creating a separate job and pods for every minute to run and verify the logs of the pod

# Answer
kubectl get job
kubectl get pokubectl logs date-job-<jobid>-<pod>

# 095. Delete the CronJob and verify all the associated jobs and pods are also deleted.

# Answer
kubectl delete cj date-job// verify pods and jobs
kubectl get po
kubectl get job
kubectl autoscale deploy webapp --min=10 --max=20 --cpu-percent=85kubectl get hpakubectl get pod -l app=webapp

# State Persistence (8%)
# 096. List Persistent Volumes in the cluster

# Answer
kubectl get pv

# 097. Create a hostPath PersistentVolume named task-pv-volume with storage 10Gi, access modes ReadWriteOnce, storageClassName manual, and volume at /mnt/data and verify

# Answer
kubectl create -f task-pv-volume.yamlkubectl get pv

# 098. Create a PersistentVolumeClaim of at least 3Gi storage and access mode ReadWriteOnce and verify status is Bound

# Answer
kubectl create -f task-pv-claim.yamlkubectl get pvc

# 099. Delete persistent volume and PersistentVolumeClaim we just created

# Answer
kubectl delete pvc task-pv-claim
kubectl delete pv task-pv-volume

100. Create a Pod with an image Redis and configure a volume that lasts for the lifetime of the Pod

// emptyDir is the volume that lasts for the life of the podkubectl create -f redis-storage.yaml
101. Exec into the above pod and create a file named file.txt with the text ‘This is called the file’ in the path /data/redis and open another tab and exec again with the same pod and verifies file exist in the same path.

// first terminal
kubectl exec -it redis-storage /bin/sh
cd /data/redis
echo 'This is called the file' > file.txt//open another tab
kubectl exec -it redis-storage /bin/sh
cat /data/redis/file.txt
102. Delete the above pod and create again from the same yaml file and verifies there is no file.txt in the path /data/redis

kubectl delete pod rediskubectl create -f redis-storage.yaml
kubectl exec -it redis-storage /bin/sh
cat /data/redis/file.txt // file doesn't exist
103. Create PersistentVolume named task-pv-volume with storage 10Gi, access modes ReadWriteOnce, storageClassName manual, and volume at /mnt/data and Create a PersistentVolumeClaim of at least 3Gi storage and access mode ReadWriteOnce and verify status is Bound

kubectl create -f task-pv-volume.yaml
kubectl create -f task-pv-claim.yamlkubectl get pv
kubectl get pvc
104. Create an nginx pod with containerPort 80 and with a PersistentVolumeClaim task-pv-claim and has a mouth path "/usr/share/nginx/html"

kubectl create -f task-pv-pod.yaml
task-pv-pod.yaml

echo ===> Configuration (18%)
105. List all the configmaps in the cluster

kubectl get cm
     or
kubectl get configmap
106. Create a configmap called myconfigmap with literal value appname=myapp

kubectl create cm myconfigmap --from-literal=appname=myapp
107. Verify the configmap we just created has this data

// you will see under datakubectl get cm -o yaml
         or
kubectl describe cm
108. delete the configmap myconfigmap we just created

kubectl delete cm myconfigmap
109. Create a file called config.txt with two values key1=value1 and key2=value2 and verify the file

cat >> config.txt << EOF
key1=value1
key2=value2
EOFcat config.txt
110. Create a configmap named keyvalcfgmap and read data from the file config.txt and verify that configmap is created correctly

kubectl create cm keyvalcfgmap --from-file=config.txtkubectl get cm keyvalcfgmap -o yaml
111. Create an nginx pod and load environment values from the above configmap keyvalcfgmap and exec into the pod and verify the environment variables and delete the pod

// first run this command to save the pod yml
kubectl run nginx --image=nginx --restart=Never --dry-run -o yaml > nginx-pod.yml// edit the yml to below file and create
kubectl create -f nginx-pod.yml// verify
kubectl exec -it nginx -- envkubectl delete po nginx
nginx-pod.yml
112. Create an env file file.env with var1=val1 and create a configmap envcfgmap from this env file and verify the configmap

echo var1=val1 > file.env
cat file.envkubectl create cm envcfgmap --from-env-file=file.env
kubectl get cm envcfgmap -o yaml --export
113. Create an nginx pod and load environment values from the above configmap envcfgmap and exec into the pod and verify the environment variables and delete the pod

// first run this command to save the pod yml
kubectl run nginx --image=nginx --restart=Never --dry-run -o yaml > nginx-pod.yml// edit the yml to below file and create
kubectl create -f nginx-pod.yml// verify
kubectl exec -it nginx -- envkubectl delete po nginx
nginx-pod.yaml
114. Create a configmap called cfgvolume with values var1=val1, var2=val2 and create an nginx pod with volume nginx-volume which reads data from this configmap cfgvolume and put it on the path /etc/cfg

// first create a configmap cfgvolume
kubectl create cm cfgvolume --from-literal=var1=val1 --from-literal=var2=val2// verify the configmap
kubectl describe cm cfgvolume// create the config map 
kubectl create -f nginx-volume.yml// exec into the pod
kubectl exec -it nginx -- /bin/sh// check the path
cd /etc/cfg
ls
nginx-volume.yml
115. Create a pod called secbusybox with the image busybox which executes command sleep 3600 and makes sure any Containers in the Pod, all processes run with user ID 1000 and with group id 2000 and verify.

// create yml file with dry-run
kubectl run secbusybox --image=busybox --restart=Never --dry-run -o yaml -- /bin/sh -c "sleep 3600;" > busybox.yml// edit the pod like below and create
kubectl create -f busybox.yml// verify
kubectl exec -it secbusybox -- sh
id // it will show the id and group
busybox.yml
116. Create the same pod as above this time set the securityContext for the container as well and verify that the securityContext of container overrides the Pod level securityContext.

// create yml file with dry-run
kubectl run secbusybox --image=busybox --restart=Never --dry-run -o yaml -- /bin/sh -c "sleep 3600;" > busybox.yml// edit the pod like below and create
kubectl create -f busybox.yml// verify
kubectl exec -it secbusybox -- sh
id // you can see container securityContext overides the Pod level
busybox.yml
117. Create pod with an nginx image and configure the pod with capabilities NET_ADMIN and SYS_TIME verify the capabilities

// create the yaml file
kubectl run nginx --image=nginx --restart=Never --dry-run -o yaml > nginx.yml// edit as below and create pod
kubectl create -f nginx.yml// exec and verify
kubectl exec -it nginx -- sh
cd /proc/1
cat status// you should see these values
CapPrm: 00000000aa0435fb
CapEff: 00000000aa0435fb
nginx.yml
118. Create a Pod nginx and specify a memory request and a memory limit of 100Mi and 200Mi respectively.

// create a yml file
kubectl run nginx --image=nginx --restart=Never --dry-run -o yaml > nginx.yml// add the resources section and create
kubectl create -f nginx.yml// verify
kubectl top pod
nginx.yml
119. Create a Pod nginx and specify a CPU request and a CPU limit of 0.5 and 1 respectively.

// create a yml file
kubectl run nginx --image=nginx --restart=Never --dry-run -o yaml > nginx.yml// add the resources section and create
kubectl create -f nginx.yml// verify
kubectl top pod
nginx.yml
120. Create a Pod nginx and specify both CPU, memory requests and limits together and verify.

// create a yml file
kubectl run nginx --image=nginx --restart=Never --dry-run -o yaml > nginx.yml// add the resources section and create
kubectl create -f nginx.yml// verify
kubectl top pod
nginx.yml
121. Create a Pod nginx and specify a memory request and a memory limit of 100Gi and 200Gi respectively which is too big for the nodes and verify pod fails to start because of insufficient memory

// create a yml file
kubectl run nginx --image=nginx --restart=Never --dry-run -o yaml > nginx.yml// add the resources section and create
kubectl create -f nginx.yml// verify
kubectl describe po nginx // you can see pending state
nginx.yml
122. Create a secret mysecret with values user=myuser and password=mypassword

kubectl create secret generic my-secret --from-literal=username=user --from-literal=password=mypassword
123. List the secrets in all namespaces

kubectl get secret --all-namespaces
124. Output the yaml of the secret created above

kubectl get secret my-secret -o yaml
125. Create an nginx pod which reads username as the environment variable

// create a yml file
kubectl run nginx --image=nginx --restart=Never --dry-run -o yaml > nginx.yml// add env section below and create
kubectl create -f nginx.yml//verify
kubectl exec -it nginx -- env
nginx.yml
126. Create an nginx pod which loads the secret as environment variables

// create a yml file
kubectl run nginx --image=nginx --restart=Never --dry-run -o yaml > nginx.yml// add env section below and create
kubectl create -f nginx.yml//verify
kubectl exec -it nginx -- env
nginx.yml
127. List all the service accounts in the default namespace

kubectl get sa
128. List all the service accounts in all namespaces

kubectl get sa --all-namespaces
129. Create a service account called admin

kubectl create sa admin
130. Output the YAML file for the service account we just created

kubectl get sa admin -o yaml
131. Create a busybox pod which executes this command sleep 3600 with the service account admin and verify

kubectl run busybox --image=busybox --restart=Never --dry-run -o yaml -- /bin/sh -c "sleep 3600" > busybox.ymlkubectl create -f busybox.yml// verify
kubectl describe po busybox
busybox.yml

echo ===> Observability (18%)
132. Create an nginx pod with containerPort 80 and it should only receive traffic only it checks the endpoint / on port 80 and verify and delete the pod.

kubectl run nginx --image=nginx --restart=Never --port=80 --dry-run -o yaml > nginx-pod.yaml// add the readinessProbe section and create
kubectl create -f nginx-pod.yaml// verify
kubectl describe pod nginx | grep -i readinesskubectl delete po nginx
nginx-pod.yaml
133. Create an nginx pod with containerPort 80 and it should check the pod running at endpoint / healthz on port 80 and verify and delete the pod.

kubectl run nginx --image=nginx --restart=Never --port=80 --dry-run -o yaml > nginx-pod.yaml// add the livenessProbe section and create
kubectl create -f nginx-pod.yaml// verify
kubectl describe pod nginx | grep -i readinesskubectl delete po nginx
nginx-pod.yaml
134. Create an nginx pod with containerPort 80 and it should check the pod running at endpoint /healthz on port 80 and it should only receive traffic only it checks the endpoint / on port 80. verify the pod.

kubectl run nginx --image=nginx --restart=Never --port=80 --dry-run -o yaml > nginx-pod.yaml// add the livenessProbe and readiness section and create
kubectl create -f nginx-pod.yaml// verify
kubectl describe pod nginx | grep -i readiness
kubectl describe pod nginx | grep -i liveness
nginx-pod.yaml
135. Check what all are the options that we can configure with readiness and liveness probes

kubectl explain Pod.spec.containers.livenessProbe
kubectl explain Pod.spec.containers.readinessProbe
136. Create the pod nginx with the above liveness and readiness probes so that it should wait for 20 seconds before it checks liveness and readiness probes and it should check every 25 seconds.

kubectl create -f nginx-pod.yaml
nginx-pod.yaml
137. Create a busybox pod with this command “echo I am from busybox pod; sleep 3600;” and verify the logs.

kubectl run busybox --image=busybox --restart=Never -- /bin/sh -c "echo I am from busybox pod; sleep 3600;"kubectl logs busybox
138. copy the logs of the above pod to the busybox-logs.txt and verify

kubectl logs busybox > busybox-logs.txtcat busybox-logs.txt
139. List all the events sorted by timestamp and put them into file.log and verify

kubectl get events --sort-by=.metadata.creationTimestamp// putting them into file.log
kubectl get events --sort-by=.metadata.creationTimestamp > file.logcat file.log
140. Create a pod with an image alpine which executes this command ”while true; do echo ‘Hi I am from alpine’; sleep 5; done” and verify and follow the logs of the pod.

// create the pod
kubectl run hello --image=alpine --restart=Never  -- /bin/sh -c "while true; do echo 'Hi I am from Alpine'; sleep 5;done"// verify and follow the logs
kubectl logs --follow hello
141. Create the pod with this kubectl create -f https://gist.githubusercontent.com/bbachi/212168375b39e36e2e2984c097167b00/raw/1fd63509c3ae3a3d3da844640fb4cca744543c1c/not-running.yml. The pod is not in the running state. Debug it.

// create the pod
kubectl create -f https://gist.githubusercontent.com/bbachi/212168375b39e36e2e2984c097167b00/raw/1fd63509c3ae3a3d3da844640fb4cca744543c1c/not-running.yml// get the pod
kubectl get pod not-running
kubectl describe po not-running// it clearly says ImagePullBackOff something wrong with image
kubectl edit pod not-running // it will open vim editor
                     or
kubectl set image pod/not-running not-running=nginx
142. This following yaml creates 4 namespaces and 4 pods. One of the pod in one of the namespaces are not in the running state. Debug and fix it. https://gist.githubusercontent.com/bbachi/1f001f10337234d46806929d12245397/raw/84b7295fb077f15de979fec5b3f7a13fc69c6d83/problem-pod.yaml.

kubectl create -f https://gist.githubusercontent.com/bbachi/1f001f10337234d46806929d12245397/raw/84b7295fb077f15de979fec5b3f7a13fc69c6d83/problem-pod.yaml// get all the pods in all namespaces
kubectl get po --all-namespaces// find out which pod is not running
kubectl get po -n namespace2// update the image
kubectl set image pod/pod2 pod2=nginx -n namespace2// verify again
kubectl get po -n namespace2
143. Get the memory and CPU usage of all the pods and find out top 3 pods which have the highest usage and put them into the cpu-usage.txt file

// get the top 3 hungry pods
kubectl top pod --all-namespaces | sort --reverse --key 3 --numeric | head -3// putting into file
kubectl top pod --all-namespaces | sort --reverse --key 3 --numeric | head -3 > cpu-usage.txt// verify
cat cpu-usage.txt

echo ===> Services and Networking (13%)
144. Create an nginx pod with a yaml file with label my-nginx and expose the port 80

kubectl run nginx --image=nginx --restart=Never --port=80 --dry-run -o yaml > nginx.yaml// edit the label app: my-nginx and create the pod
kubectl create -f nginx.yaml
nginx.yaml
145. Create the service for this nginx pod with the pod selector app: my-nginx

// create the below service
kubectl create -f nginx-svc.yaml
nginx-svc.yaml
146. Find out the label of the pod and verify the service has the same label

// get the pod with labels
kubectl get po nginx --show-labels// get the service and chekc the selector column
kubectl get svc my-service -o wide
147. Delete the service and create the service with kubectl expose command and verify the label

// delete the service
kubectl delete svc my-service// create the service again
kubectl expose po nginx --port=80 --target-port=9376// verify the label
kubectl get svc -l app=my-nginx
148. Delete the service and create the service again with type NodePort

// delete the service
kubectl delete svc nginx// create service with expose command
kubectl expose po nginx --port=80 --type=NodePort
149. Create the temporary busybox pod and hit the service. Verify the service that it should return the nginx page index.html.

// get the clusterIP from this command
kubectl get svc nginx -o wide// create temporary busybox to check the nodeport
kubectl run busybox --image=busybox --restart=Never -it --rm -- wget -o- <Cluster IP>:80
150. Create a NetworkPolicy which denies all ingress traffic

apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  
